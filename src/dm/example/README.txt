单一职责
开发封闭
依赖倒转
最少知识
里氏替换: 子类可以扩展父类的功能，但不能改变父类原有的功能
接口隔离

* 创建型模式

抽象工厂 创建一系列或相关依赖对象的接口
   关键词： 创建系列对象

建造者 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示
      关键词： director(builder) - 构建顺序； builder - 构建动作；里面包含产品（比如零件列表，里面包含产品的各零件，顺序代表组装顺序）
      
工厂方法 让子类决定实例化哪一个类， 使类的实例化延迟到子类
      关键词 product -> concreteProduct; Creator(FactioryMethod()) -> ConcreteCreator
       通常设计从工厂方法开始，当需要更大的灵活性时，设计便会向其他创建型模式演化
      
原型  用原型实例指定创建对象的种类， 并且通过拷贝这些原型创建新的对象
    关键词 clone()
    
单例 保证一个类仅有一个实例， 并提供一个访问它差全局访问点
   关键词 private Xxx(); Xxx getInstance()
   
* 结构型模式

适配器 将一个类的接口转换成客户希望的另一个接口。使得原来由于接口不兼容而不能一起工作的类可以一起工作
    关键是： 适配（往往有老的类要适配为新的接口，复用已有的类）
    
桥接 将抽象部分与它的实现部分分离，使它们可以独立地变化
      关键词： Abstraction { Implementor imp; operation() {imp.operationImp()}; }
        把继承关系变为组合关系，从而可以独立变化；找出变化并封装之
      
组合 将对象组合成树形结构以表示“部分-整理”的层次结构
   关键词： IComponent -> _Compoent -> Leaf, Composite
   
装饰 动态地给一个对象添加一些额外的职责。就增加功能来说，装饰模式相对子类更加灵活
        继承为了扩展变化，会产生大量的子类
     关键词： Decorator implements Component { Component c; operate() {c.operator(); +新功能} }
     动态、透明的方式给当个对象添加职责
   
外观 为子系统中的一组接口提供一个一直的界面， 外观定义了一个高层的接口，使得这一子系统更加容易使用
     关键词： 子系统的增强型util
  
享元 为运用共享技术有效的支持大量细粒度的对象
      关键词：共享

代理 为其他对象提供一种代理以控制对这个对象的访问
     关键词： 控制; 隔离对原对象的访问
     使用RealSubject的地方都可以使用Proxy， 因为RealSubject和Proxy实现一个公用的接口

* 行为型模式

观察者： 对象中一对多的依赖关系。一个对象状态改变，所有依赖它的对象将得到通知并被自动更新。

模板：定义操作的算法骨架，而将一些具体的步骤延迟到子类实现。不改变算法的接口，可以重定义该算法的某些特定步骤。

命令：将一个请求封装为一个对象，可以用不同的请求对客户进行参数化；可以对请求排队，记录日志，可撤销
     将调用操作的对象 和 直到如何执行的对象 解耦

状态：修改一个类的内部状态时改变它的行为，让对象看起来似乎修改了它的类
     (关键代码State.handle(context); Context.request(){this.state.handle(this);})
          状态转移逻辑避免在单个的if或switch中
     
责任链：使多个对象都有机会处理请求，避免请求的发送者和接受者之间的紧耦合。处理对象连城一条链，沿着这条链传递请求，直到对象被处理。
     (关键代码 handler.success; if(){handle code} else {this.success.handle()}
      
解释器 给定一个语言，定义它的文法的一种表示；定义一个解释器，使用该表示来解释语言中的句子

中介者 封装一系列对象交互。使各对象不需要显式地相互引用，而从使其耦合松散， 可以独立地改变他们之间的交互。

访问者 作用于某对象结构中的个元素的操作。可以在不改变各元素的前提下定义作用于这些元素的新操作。
      增加具体的element困难，但增加依赖于复杂对象结构的构建的操作变得容易，增加一个访问者，就能增加一个操作 
      关键代码： vistor.visitElementX(elementX) { 访问逻辑... }; elementX.accept(visitor) {visitor.visitElementX(this)}
      
策略 定义一系列算法，一一封装起来，并且使他们可以互相替换。算法可独立于使用它的客户而变化

备忘录 不破坏封装前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。
      模式关键词： memento, caretaker, originor

迭代器 提供一种方法顺序访问聚合对象中各元素， 而不暴露内部结构